1. 文件句柄与文件描述符有相同的作用，但是又是不同的东西。
   文件句柄=>文件描述符：fileno(F);返回文件描述符
==============================================================
2. 访问模式
   只读：>，或省略，为读打开文件，不存在则打开失败
   只写：<，为写打开文件，不存在则创建，存在则清除文件内容再写
   追加：>>，为写打开文件，文件不存在则创建，直接在文件后面追加，
不清除内容
   读写：+<，可读可写，文件不存在则失败，不清除，不追加，直接覆盖
   读写：+>，可读可写，文件不存在则创建，若存在清除内容再写
   读写：+>>，可读可写，文件不存在则创建，文件存在则追加
   管道：|，
       open(F, "|cat>hello");把文件F的输出作为|后的输入。
       open(F, "comm|");把comm的输出作为F的输入。
=================================================================
3. 文件名
   filename:含相对路径或绝对路径的文件名
   open()打开成功返回非零，失败返回0
=================================================================
4. 读文件
   $line=<file> 读取一行
   @array=<file> 文件内容全部读出来。
   <>从STDIN读取
   read(F, $in, len[,$offset])读入$in
   sysread(F, $in, len[,offset])
   getc(F);读取一个字符
=================================================================
5. 命令行参数
   @ARGV：全局，$ARGV[0]是第一个参数，不是程序名。
   （1）第一次看到<>时，打开以$ARGV[0]中的文件。无参数数时打开STDIN
   （2）shift(@ARGV)，元素数量减少一个
   文件结束符eof和eof()：
   @ARGV = ("file1","file2");
   while($line=<>){if(eof){print 'eof';}}
   eof每读完一个文件输出一个eof,而eof()所有的文件读完才输出eof。
==================================================================
6. 写文件
   print F("str");F为文件句柄，后面为空格，省略F为STDOUT。str为输出
内容，可用单引号，不进行变量替换，不加引号计算出变量的值再输出。
()可以省略。这是函数的特点。
   printf("format str", $a, $b...)与c语言一样
   write用于格式化输出，不是read的相应操作。
   syswrite(F, $data, length, $offset);同sysread 。。。按字节读而
非按行读
==================================================================
7. 文件权限
   chmod(mode, filelst);
   chown(userid, groupid, filelst);
   umask(maskval)；返回原mask
   
   文件指针：
   tell(F)当前位置。windows中换行为两个字符
   seek(F, distance, pos);定位到制定位置。F文件句柄，pos=0相对文件头，
1相对文件当前位置，2相对文件尾，distance相对pos表示多少字节。
