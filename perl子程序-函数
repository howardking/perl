1. 子程序的定义
   sub subroutine{
       statements;
   }
   带有原型说明的子程序定义：
   sub subroutine($$){    #需要两个简单变量的参数
      statements;
   }
   ()中的符号表示参数的类型。以一个字符表示一个参数
   $ 简单变量
   @ 列表
   % 散列
   & 匿名子程序
   * 引用
   前面加\为强制类型一致。；分割必须的参数和可选参数。
   \@$;$表示第一个参数为列表，第二个参数为简单变量，第三个参数为可选简单变量
============================================================================
2. 返回值
   （1）缺省子程序中最后执行的一个语句的值将用作返回值，如果在if块中为最后执行的语句，则返回这个语句块中最后执行的语句的值。
   （2）语句return(retval);退出子程序并返回值retval,retval可以为列表
   （3）返回错误
        return;返回错误undef
        用eval('subroutine');函数，错误由$@变量中取得。
============================================================================
3. 参数传递
   &sub1($number, $number2, $number3);

   sub sub1{
       my($number1, $number2, $number3) = @_;
   }
   或
   my $number1 = shift;
   my $number2 = shift;
   my $number3 = pop;

   所有参数在数组@_中，每个元素为$_[0],$_[1]
   @_,$_[]为局部变量，当子程序再调用子程序时，@_不改变，会生成一个新的@_
   改变@_内元素的值如$_[0]会改变主程序的参数值。
   shift取一个参数，再删除，pop取最后一个参数再删除
============================================================================
4. 局部变量
   全局变量：不加说明的变量为全局变量，子程序中修改会改变其值
   局部变量my：用my说明的变量如：my $a;作用域为定义改变量的程序块。
   local定义的变量可以在子程序中使用，而my定义的不能在不同级子程序块中使用。
   local在本块内改变全局的值如$/,出了块就恢复。内部变量不能用my声明。
==========================================================================
5. 调用子程序
   &标准调用：&subname(1, 2); #无论在什么地方定义都可以
   常用调用： subname(1, 2);  #只有在调用前已经定义才可以
   前向引用：先声明，再调用，再定义。
   sub subname;
   subname(1, 2);
   sub subname{...}
   用do调用：do subname(1, 2);
   引用：&$subref(1, 2); #&不能省略  
=======================================================================
6. 预定义的子程序
   BEGIN 子程序在程序启动时被调用
   END 子程序在程序结束时被调用
   AUTOLOAD 子程序在找不到某个子程序时被调用。

